/* Generated by RuntimeBrowser
   Image: /System/Library/Frameworks/AppKit.framework/Versions/C/AppKit
 */

@interface NSPersistentUIManager : NSObject <NSPersistentUIFlushHandler> {
    NSPersistentUICrashHandler * _crashHandler;
    NSPersistentUIEncodingQueue * _encodingQueue;
    NSPersistentUIFileManager * _fileManager;
    NSPersistentUIFlushScheduler * _flushScheduler;
    BOOL  _isClosedToChanges;
    struct os_unfair_lock_s { 
        unsigned int _os_unfair_lock_opaque; 
    }  _lock;
    NSPersistentUIRestorer * _stateRestorer;
    NSPersistentUIWindowSnapshotter * _windowSnapshotter;
    NSMutableDictionary * additionalBuckets;
    NSMapTable * objectToPendingKeyPaths;
    NSMutableArray * pendingRecords;
    NSMutableArray * sortedWindowInfos;
    BOOL  treatEverythingAsDirty;
    NSObject<OS_dispatch_queue> * workQueue;
}

@property (atomic, readonly, copy) NSString *debugDescription;
@property (atomic, readonly, copy) NSString *description;
@property (atomic, readonly) unsigned long long hash;
@property (atomic, readonly) Class superclass;

+ (id)_debugUnrestoredWindows;
+ (void)_didDecodeObject:(id)arg1 uid:(unsigned int)arg2;
+ (void)nibDecoder:(id)arg1 didDecodeObject:(id)arg2;
+ (id)sharedManager;
+ (id)unarchiver:(id)arg1 didDecodeObject:(id)arg2;

- (void)_cancelFlushTimer;
- (void)_finishPendingChangesImmediatelyWithCompletionHandler:(id)arg1;
- (id)_flushScheduler;
- (void)_setPublicProperties:(id)arg1 forWindowID:(unsigned int)arg2;
- (void)acquireDirtyState;
- (void)addObjectInBackgroundForKeyedState:(id)arg1 underKey:(id)arg2 forIdentifier:(id)arg3 inWindow:(unsigned int)arg4;
- (void)addPendingKeyPath:(id)arg1 forObject:(id)arg2;
- (void)changePersistentKeyPathObservationForPaths:(id)arg1 inObject:(id)arg2 to:(BOOL)arg3;
- (void)changeWindow:(unsigned int)arg1 toStatus:(int)arg2 withConditionalGeneration:(unsigned int)arg3;
- (void)clearCrashCountFileIfNecessary;
- (long long)crashBlameCounter;
- (void)dealloc;
- (void)delayCGWindowOrderingIfNecessary;
- (void)disableRestorableStateWriting;
- (void)discardAllPersistentStateAndClose;
- (void)enableRestorableStateWriting;
- (void)flushAllChanges;
- (void)flushForScheduler:(id)arg1;
- (void)flushPersistentStateAndClose;
- (void)flushPersistentStateAndClose:(BOOL)arg1 waitingUntilDone:(BOOL)arg2;
- (void)fullyDirtyAndReopenPersistentState;
- (BOOL)hasFinishedRestoringWindows;
- (BOOL)hasPersistentStateToRestore;
- (void)ignoreAnyPreexistingPersistentState;
- (id)init;
- (void)invalidateStateDirectoryAtLaunch;
- (unsigned int)modifyCrashBlameCounterBy:(int)arg1;
- (void)observeValueForKeyPath:(id)arg1 ofObject:(id)arg2 change:(id)arg3 context:(void*)arg4;
- (void)performDockCommands:(id)arg1 withOldWindowIDToNewWindowID:(id)arg2;
- (BOOL)performingWindowOrdering;
- (id)persistentStateDirectoryURL;
- (BOOL)promptToIgnorePersistentState;
- (void)refreshEncryptionKey:(BOOL)arg1;
- (BOOL)restoreAllPersistentStateWithCompletionHandler:(id)arg1;
- (void)resumeNormalWindowOrderingAndDrawing;
- (void)setPublicProperties:(id)arg1 forWindowID:(unsigned int)arg2;
- (BOOL)shouldRestoreStateOnLaunch;
- (BOOL)shouldUseOneWindowHeuristic;
- (id)stateDirectoryAtLaunch;
- (id)windowInfoForWindowID:(unsigned int)arg1 createIfNecessary:(BOOL)arg2;
- (void)writePublicPlistWithOpenWindowIDs:(id)arg1;

// NSPersistentUIManager (NSCarbonMethods)

+ (id)copyDebugDumpStateDirectory:(id)arg1;
+ (id)copyPersistentCarbonWindowDictionariesForBundleID:(id)arg1;

- (id)copyPersistentCarbonWindowDictionariesAtTimeOfAppLaunch;
- (unsigned int)createPersistentWindow;
- (void)deletePersistentWindow:(unsigned int)arg1;
- (void)setObject:(id)arg1 forKey:(id)arg2 forPersistentWindowID:(unsigned int)arg3;

// NSPersistentUIManager (NSPersistentUIManagerExtensions)

+ (id)_NSPersistentUIAcquireTalagentWindowsOnConnections:(unsigned int)arg1 :(id)arg2;
+ (void)_NSPersistentUIDestroyTalagentWindows:(unsigned int)arg1 :(id)arg2;

- (void)beginAcquiringExternallyCreatedWindows;
- (id)copyAcquiredExternallyCreatedWindows;
- (void)destroyExternallyCreatedWindows:(id)arg1;

// NSPersistentUIManager (NSWindowOrderingSuppression)

+ (id)_copyCGWindowOrderingReplayer;
+ (void)_permitWindowOrderingUntilStateRestoration;
+ (void)_resuppressWindowOrderingNowThatStateRestorationIsOccurring;
+ (BOOL)_suppressCGWindowOrdering;

@end
